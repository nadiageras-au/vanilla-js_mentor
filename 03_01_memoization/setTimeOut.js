// Убедитесь, что продолжительность выполнения короче интервальной частоты.

// Если существует вероятность того, что выполнение вашей логики может занять больше времени, чем интервал времени,
// рекомендуется рекурсивно вызывать именованную функцию, используя setTimeout().
// Например, если вы используете setInterval() опрос удаленного сервера каждые 5 секунд,
// задержка в сети, не отвечающий сервер и множество других проблем могут помешать выполнению запроса в отведенное время.
// Таким образом, вы можете оказаться в очереди с запросами XHR, которые не обязательно вернутся по порядку.

    // (function loop() {
    //     const timerId = setTimeout(() => {
    //         // Your logic here
    //         console.log("eee")
    //         loop();
    //         clearTimeout(timerId)
    //     }, 1000);
    // })();
// Хотя этот шаблон не гарантирует выполнение в фиксированном интервале,
// он гарантирует, что предыдущий интервал завершится до рекурсии.
// Recursive setTimeout подходит, когда нужно, чтобы процесс обратного вызова обращался к одному ресурсу,
// который может быть обновлён.
// Также он идеален, если процесс обратного вызова завершается в течение указанного интервала.
//   В отличие от setInterval, таймер в recursive setTimeout начинается только после вызова функции setTimeout в обратном вызове.
//   Это означает, что программа не движется вперёд, пока внутренняя функция не завершит обработку. Это гарантирует,
//   что ресурс будет доступен последовательно.
//   SetInterval — это ещё один вариант для выполнения функций с указанными интервалами.
//   В отличие от recursive setTimeout, setInterval запускает таймер сразу после вызова,
//   и обратный вызов срабатывает каждый указанный интервал без ожидания завершения предыдущего вызова.
//   Выбор между этими двумя методами зависит от конкретных требований приложения.

        // (function loop() {
        //     const timerId = setTimeout(() => {
        //         // Your logic here
        //         console.log("eee")
        //         loop();
        //         clearTimeout(timerId)
        //     }, 1000);
        // })();

const timerId = setTimeout(()=>{}, 0);
console.log(timerId)

